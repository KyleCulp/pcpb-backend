CREATE TABLE app_public.user_account (
  user_id uuid PRIMARY KEY DEFAULT PUBLIC.uuid_generate_v1mc (),
  username text UNIQUE,
  email_confirmed boolean NOT NULL DEFAULT FALSE,
  roles text NOT NULL DEFAULT 'user',
  created_at timestamp DEFAULT now(),
  updated_at timestamp DEFAULT now(),
  CHECK (char_length(username) <= 32)
);

COMMENT ON TABLE app_public.user_account IS 'A user’s public account';

COMMENT ON COLUMN app_public.user_account.user_id IS 'Globally unique identifier for a user. Autogenerated.';

-- PostgreSQL treats NULL as distinct value, therefore, you can have multiple NULL values in a column with a UNIQUE index.
COMMENT ON COLUMN app_public.user_account.username IS 'Unique username. Can be null.';

COMMENT ON COLUMN app_public.user_account.email_confirmed IS 'The status of users confirmed email.';

COMMENT ON COLUMN app_public.user_account.roles IS 'The users role.';

COMMENT ON COLUMN app_public.user_account.created_at IS 'The time this person was created.';

COMMENT ON COLUMN app_public.user_account.updated_at IS 'The time this person was last updated.';

-- Anyone can read data from this table
GRANT SELECT ON TABLE app_public.user_account TO app_anonymous, app_postgraphile, app_person;

-- Only logged in people can update & delete it.
-- No inserting, postgres functions handle user creation
-- This RBAC helps us differentiate guest from users

GRANT UPDATE, DELETE ON TABLE app_public.user_account TO app_postgraphile, app_person;

-- Drop policy if exist, then recreate it every time
-- Let anyone select on this row

DROP POLICY IF EXISTS select_user_account ON app_public.user_account;

CREATE POLICY select_user_account ON app_public.user_account FOR SELECT USING (TRUE);

-- CREATE POLICY update_user_account ON app_public.user_account
--     FOR UPDATE TO app_postgraphile
--     USING (user_id = current_setting('jwt.claims.user_id', true)::UUID);
-- CREATE POLICY delete_user_account ON app_public.user_account
--     FOR DELETE TO app_account
--     USING (user_id = current_setting('jwt.claims.user_id', true)::UUID);

CREATE TABLE app_private.user_account_private (
  user_id uuid PRIMARY KEY REFERENCES app_public.user_account (user_id) ON DELETE CASCADE,
  email text UNIQUE,
  password_hash text NOT NULL,
  updated_at timestamp DEFAULT now(),
  CHECK (email ~* '^.+@.+\..+$')
);

COMMENT ON TABLE app_private.user_account_private IS 'Private information about a person’s account.';

COMMENT ON COLUMN app_private.user_account_private.user_id IS 'The id of the person associated with this account.';

COMMENT ON COLUMN app_private.user_account_private.email IS 'The email address of the person.';

COMMENT ON COLUMN app_private.user_account_private.password_hash IS 'A hash of the person’s password.';

----------
CREATE OR REPLACE FUNCTION app_private.set_updated_at ()
  RETURNS TRIGGER
  AS $$
BEGIN
  NEW.updated_at := CURRENT_TIMESTAMP;
  RETURN NEW;
END;
$$
LANGUAGE PLPGSQL;

COMMENT ON FUNCTION app_private.set_updated_at IS 'Function to handle updated_at columns.';

-- Drop trigger to replace it
DROP TRIGGER IF EXISTS user_account_private_updated_at ON app_private.user_account_private;

CREATE TRIGGER user_account_private_updated_at
  BEFORE UPDATE ON app_private.user_account_private
  FOR EACH ROW
  EXECUTE PROCEDURE app_private.set_updated_at ();

DROP TRIGGER IF EXISTS user_account_updated_at ON app_public.user_account;

CREATE TRIGGER user_account_updated_at
  BEFORE UPDATE ON app_public.user_account
  FOR EACH ROW
  EXECUTE PROCEDURE app_private.set_updated_at ();

